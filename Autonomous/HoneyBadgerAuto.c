#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Hubs,  S2, HTMotor,  HTMotor,  none,     none)
#pragma config(Hubs,  S3, HTServo,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     intake,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     pretake,       tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     lift1,         tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     lift2,         tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S2_C1_1,     leftWheel1,    tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S2_C1_2,     leftWheel2,    tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S2_C2_1,     rightWheel1,   tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S2_C2_2,     rightWheel2,   tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Servo,  srvo_S3_C1_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S3_C1_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S3_C1_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S3_C1_4,    rightHook,            tServoStandard)
#pragma config(Servo,  srvo_S3_C1_5,    leftHook,             tServoStandard)
#pragma config(Servo,  srvo_S3_C1_6,    waterspout,           tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void setAllLeftWheels (int target) {
	motor[leftWheel1] = target;
	motor[leftWheel2] = target;
}

void setAllRightWheels (int target) {
	motor[rightWheel1] = target;
	motor[rightWheel2] = target;
}

void setAllWheels (int target) {
	setAllLeftWheels(target);
	setAllRightWheels(target);
}
void setAllLifts (int target) {
	motor[lift1] = target;
	motor[lift2] = target;
}

void putHookUp () {
	servo[leftHook]=207;				//Set left hook to up position
	servo[rightHook]=52;				//Set right hook to up position
}

void putHookDown() {
	servo[leftHook]=73;
	servo[rightHook]=174;
}

void waterspoutRelease () {
	servo[waterspout] = 62;
}

void waterspoutCatch () {
	servo[waterspout] = 165;
}

void waterspoutStart () {
	servo[waterspout] = 255;
}

void setLift (int target) {
	bool okay = false;
	while(!okay) {
		int test = abs(nMotorEncoder[lift1]);
		int adjTarget = abs(target);
		if(nMotorEncoder[lift1]>target) {
			setAllLifts(100);
			} else if (nMotorEncoder[lift1]<target) {
			setAllLifts(-100);
			} else if ((test>(adjTarget-10)) && (test<(adjTarget+10))) {
			setAllLifts(0);
		}
	}
}

void driveOffRamp () {
	nMotorEncoder[leftWheel1] = 0;
	nMotorEncoder[rightWheel1] = 0;

	float Kp = 0.5;
	float Ki = 0.2;
	float Kd = 0.1;
	int targetValue = -100; //Calib Needed
	float error, speed, integral, derivative, previousError = 0;
	while(true) {
		//P
		error = targetValue - nMotorEncoder[leftWheel1];

		//I
		integral += error;

		if(error == 0 || abs(error) > 40)
			integral=0;

		//D
		derivative = error-previousError;

		previousError = error;

		setAllWheels(Kp * error + Ki * integral + Kd * derivative);
	}
}

void backIntoGoal () {
	nMotorEncoder[leftWheel1] = 0;
	nMotorEncoder[rightWheel1] = 0;

	float Kp = 0.5;
	float Ki = 0.2;
	float Kd = 0.1;
	int targetValue = -100; //Calib Needed
	float error, speed, integral, derivative, previousError = 0;
	while(true) {
		//P
		error = targetValue - nMotorEncoder[leftWheel1];

		//I
		integral += error;

		if(error == 0 || abs(error) > 40)
			integral=0;

		//D
		derivative = error-previousError;

		previousError = error;

		setAllWheels(Kp * error + Ki * integral + Kd * derivative);
	}
}

void putUpLift() {
	nMotorEncoder[lift1] = 0;

	float Kp = 0.5;
	float Ki = 0.2;
	float Kd = 0.1;
	int targetValue = -100; //Calib Needed
	float error, speed, integral, derivative, previousError = 0;
	while(true) {
		//P
		error = targetValue - nMotorEncoder[leftWheel1];

		//I
		integral += error;

		if(error == 0 || abs(error) > 40)
			integral=0;

		//D
		derivative = error-previousError;

		previousError = error;

		speed = Kp * error + Ki * integral + Kd * derivative;

		motor[lift1] = speed;
		motor[lift2] = speed;
	}
}

void turnToParkingZone() {
	setAllLeftWheels(50);
	wait1Msec(100);
	setAllWheels(0);
}

void moveToParkingZone() {
	nMotorEncoder[leftWheel1] = 0;
	nMotorEncoder[rightWheel1] = 0;

	float Kp = 0.5;
	float Ki = 0.2;
	float Kd = 0.1;
	int targetValue = 300; //Calib Needed
	float error, speed, integral, derivative, previousError = 0;
	while(true) {
		//P
		error = targetValue - nMotorEncoder[leftWheel1];

		//I
		integral += error;

		if(error == 0 || abs(error) > 40)
			integral=0;

		//D
		derivative = error-previousError;

		previousError = error;

		setAllWheels(Kp * error + Ki * integral + Kd * derivative);
	}
}

task main()
{
	waterspoutStart();
	waitForStart();
	driveOffRamp();
	putUpLift();
	putHookUp();
	backIntoGoal();
	putHookDown();
	waterspoutRelease();
	turnToParkingZone();
	moveToParkingZone();
}
